# Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.
# If the product in the sliding window is under the target, every subset in the window also is under target. 
# We add in elements to the right, adding all the new contiguous subarrays that adding it has created (which is the size of the window). 
# Once we go over the target, we start popping off elements from the left with a while loop.
# Time complexity: O(N) (technically N+N because of the left increments at worst case) // Space complexity: O(1)

def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
    # Array is all positive (min 1). There are no solutions when k = 1 or less, as our product has to be smaller than k. Thus:
    if k <= 1:
        return 0
    
    # Variables - product initalised to 1 so it doesn't alter the first element
    product = 1
    ans = 0
    left = 0
    # Iterate right pointer over the array
    for right in range(len(nums)):
        product *= nums[right]
        # If condition is not met, then we want to stop incrementing until the window is valid. No need for window constraint as left will, at most, be +1 over right 
        while product >= k:
            # Remove left elements until the window is valid
            product /= nums[left]
            left += 1

        # We have a 'valid' window because the while loop will root out all invalid cases. Thus, no need for conditional here.
        # We add the total new subarrays generated by the new element, which happens to be equal to the length of the window.
        ans += right - left + 1 
    return ans

        # In this implementation, left CAN go one to the right of the right pointer. 
        # Luckily, in this implementation, it would mean that ans+= 0, meaning there is no effect on the code. 